/*
 * test_parser.c
 *
 * Copyright (c) 2009-2012 project bchan
 *
 * This software is provided 'as-is', without any express or implied
 * warranty. In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 *
 * 2. Altered source versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 3. This notice may not be removed or altered from any source
 *    distribution.
 *
 */

#include    "test.h"

#include    "parser.h"

#include    <btron/btron.h>
#include	<tcode.h>
#include    <bstdio.h>
#include    <bstring.h>

#include    "cache.h"

#include    <unittest_driver.h>

LOCAL UB test_cache_testdata_01[] = {
	0x81, 0xa0, 0x81, 0xa0, 0x81, 0xa0, 0x81, 0xa0,
	0x28, 0x83, 0x6c, 0x81, 0x5b, 0x83, 0x80, 0x96,
	0xb3, 0x82, 0xb5, 0x29, 0x3c, 0x3e, 0x3c, 0x3e,
	0x32, 0x30, 0x30, 0x39, 0x2f, 0x31, 0x30, 0x2f,
	0x31, 0x36, 0x28, 0x8b, 0xe0, 0x29, 0x20, 0x32,
	0x31, 0x3a, 0x32, 0x38, 0x3a, 0x34, 0x31, 0x20,
	0x3c, 0x3e, 0x20, 0x61, 0x62, 0x63, 0x20, 0x3c,
	0x62, 0x72, 0x3e, 0x20, 0x78, 0x79, 0x7a, 0x20,
	0x3c, 0x3e, 0x82, 0xbd, 0x82, 0xa2, 0x82, 0xc6,
	0x82, 0xe9, 0x0a, 0x81, 0xa0, 0x81, 0xa0, 0x81,
	0xa0, 0x81, 0xa0, 0x28, 0x83, 0x6c, 0x81, 0x5b,
	0x83, 0x80, 0x96, 0xb3, 0x82, 0xb5, 0x29, 0x3c,
	0x3e, 0x3c, 0x3e, 0x32, 0x30, 0x30, 0x39, 0x2f,
	0x31, 0x30, 0x2f, 0x31, 0x36, 0x28, 0x8b, 0xe0,
	0x29, 0x20, 0x32, 0x32, 0x3a, 0x31, 0x39, 0x3a,
	0x34, 0x36, 0x20, 0x3c, 0x3e, 0x20, 0x3c, 0x61,
	0x20, 0x68, 0x72, 0x65, 0x66, 0x3d, 0x22, 0x2e,
	0x2e, 0x2f, 0x74, 0x65, 0x73, 0x74, 0x2f, 0x72,
	0x65, 0x61, 0x64, 0x2e, 0x63, 0x67, 0x69, 0x2f,
	0x64, 0x75, 0x6d, 0x6d, 0x79, 0x2f, 0x78, 0x78,
	0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
	0x2f, 0x31, 0x22, 0x20, 0x74, 0x61, 0x72, 0x67,
	0x65, 0x74, 0x3d, 0x22, 0x5f, 0x62, 0x6c, 0x61,
	0x6e, 0x6b, 0x22, 0x3e, 0x26, 0x67, 0x74, 0x3b,
	0x26, 0x67, 0x74, 0x3b, 0x31, 0x3c, 0x2f, 0x61,
	0x3e, 0x20, 0x3c, 0x3e, 0x0a, 0x81, 0xa0, 0x81,
	0xa0, 0x81, 0xa0, 0x81, 0xa0, 0x28, 0x83, 0x6c,
	0x81, 0x5b, 0x83, 0x80, 0x96, 0xb3, 0x82, 0xb5,
	0x29, 0x3c, 0x3e, 0x3c, 0x3e, 0x32, 0x30, 0x30,
	0x39, 0x2f, 0x31, 0x30, 0x2f, 0x31, 0x36, 0x28,
	0x8b, 0xe0, 0x29, 0x20, 0x32, 0x32, 0x3a, 0x32,
	0x34, 0x3a, 0x35, 0x37, 0x20, 0x3c, 0x3e, 0x20,
	0x3c, 0x62, 0x72, 0x3e, 0x20, 0x20, 0x3c, 0x62,
	0x72, 0x3e, 0x20, 0x20, 0x3c, 0x62, 0x72, 0x3e,
	0x20, 0x3c, 0x3e, 0x0a, 0x81, 0xa0, 0x81, 0xa0,
	0x81, 0xa0, 0x81, 0xa0, 0x28, 0x83, 0x6c, 0x81,
	0x5b, 0x83, 0x80, 0x96, 0xb3, 0x82, 0xb5, 0x29,
	0x3c, 0x3e, 0x73, 0x61, 0x67, 0x65, 0x3c, 0x3e,
	0x32, 0x30, 0x30, 0x39, 0x2f, 0x31, 0x30, 0x2f,
	0x31, 0x36, 0x28, 0x8b, 0xe0, 0x29, 0x20, 0x32,
	0x32, 0x3a, 0x33, 0x32, 0x3a, 0x31, 0x36, 0x20,
	0x3c, 0x3e, 0x20, 0x83, 0x58, 0x83, 0x8c, 0x82,
	0xbd, 0x82, 0xc1, 0x82, 0xbd, 0x82, 0xcc, 0x82,
	0xa9, 0x82, 0x97, 0x20, 0x3c, 0x62, 0x72, 0x3e,
	0x20, 0x20, 0x3c, 0x62, 0x72, 0x3e, 0x20, 0x3c,
	0x3e, 0x0a, 0x81, 0xa0, 0x81, 0xa0, 0x81, 0xa0,
	0x81, 0xa0, 0x28, 0x83, 0x6c, 0x81, 0x5b, 0x83,
	0x80, 0x96, 0xb3, 0x82, 0xb5, 0x29, 0x3c, 0x3e,
	0x73, 0x61, 0x67, 0x65, 0x3c, 0x3e, 0x32, 0x30,
	0x30, 0x39, 0x2f, 0x31, 0x30, 0x2f, 0x31, 0x37,
	0x28, 0x93, 0x79, 0x29, 0x20, 0x30, 0x34, 0x3a,
	0x34, 0x38, 0x3a, 0x31, 0x39, 0x20, 0x3c, 0x3e,
	0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x74, 0x65,
	0x73, 0x74, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20,
	0x3c, 0x3e, 0x0a, 0x00
};

LOCAL W test_parser_util_gen_file(LINK *lnk, VID *nvid)
{
	LINK lnk0;
	W fd, err;
	TC name[] = {TK_t, TNULL};
	VOBJSEG vseg = {
		{{0,0,100,20}},
		16, 16,
		0x10000000, 0x10000000, 0x10FFFFFF, 0x10FFFFFF,
		0
	};

	err = get_lnk(NULL, &lnk0, F_NORM);
	if (err < 0) {
		return err;
	}
	err = cre_fil(&lnk0, name, NULL, 0, F_FLOAT);
	if (err < 0) {
		return err;
	}
	fd = err;
	err = oreg_vob((VLINK*)&lnk0, (VP)&vseg, -1, V_NODISP);
	if (err < 0) {
		cls_fil(fd);
		del_fil(NULL, &lnk0, 0);
		return err;
	}

	*lnk = lnk0;
	*nvid = err;

	return fd;
}

LOCAL UNITTEST_RESULT test_parser_1()
{
	LINK test_lnk;
	W fd, err;
	VID vid;
	datcache_t *cache;
	datparser_t *parser;
	datparser_res_t *res = NULL;
	UNITTEST_RESULT result = UNITTEST_RESULT_PASS;

	fd = test_parser_util_gen_file(&test_lnk, &vid);
	if (fd < 0) {
		return UNITTEST_RESULT_FAIL;
	}
	cls_fil(fd);

	cache = datcache_new(vid);
	datcache_appenddata(cache, test_cache_testdata_01, strlen(test_cache_testdata_01));

	parser = datparser_new(cache);

	for (;;) {
		err = datparser_getnextres(parser, &res);
		if (err != 1) {
			break;
		}
		if (res != NULL) {
			if (res->name != NULL) {
				printf("name:\n%S\n", res->name);
			}
			if (res->mail != NULL) {
				printf("mail:\n%S\n", res->mail);
			}
			if (res->date != NULL) {
				printf("date:\n%S\n", res->date);
			}
			if (res->body != NULL) {
				printf("body:\n%S\n", res->body);
			}
			if (res->title != NULL) {
				printf("title:\n%S\n", res->title);
			}
			datparser_res_delete(res);
		} else {
			break;
		}
	}

	datparser_delete(parser);

	datcache_delete(cache);

	err = odel_vob(vid, 0);
	if (err < 0) {
		printf("error odel_vob:%d\n", err >> 16);
		result = UNITTEST_RESULT_FAIL;
	}
	err = del_fil(NULL, &test_lnk, 0);
	if (err < 0) {
		printf("error del_fil:%d\n", err >> 16);
		result = UNITTEST_RESULT_FAIL;
	}

	return result;
}

LOCAL UB test_parser_testdata_02[] = {
	0x6e, 0x61, 0x6d, 0x65, 0x3c, 0x3e, 0x6d, 0x61,
	0x69, 0x6c, 0x3c, 0x3e, 0x64, 0x61, 0x74, 0x65,
	0x3c, 0x3e, 0x6d, 0x73, 0x67, 0x3c, 0x3e, 0x26,
	0x0a, 0x26, 0x3c, 0x3e, 0x3c, 0x3e, 0x3c, 0x3e,
	0x3c, 0x3e, 0x0a, 0x3c, 0x3e, 0x26, 0x3c, 0x3e,
	0x3c, 0x3e, 0x3c, 0x3e, 0x0a, 0x3c, 0x3e, 0x3c,
	0x3e, 0x26, 0x3c, 0x3e, 0x3c, 0x3e, 0x0a, 0x3c,
	0x3e, 0x3c, 0x3e, 0x3c, 0x3e, 0x26, 0x3c, 0x3e,
	0x0a, 0x3c, 0x3e, 0x3c, 0x3e, 0x3c, 0x3e, 0x20,
	0x26, 0x3c, 0x62, 0x72, 0x3e, 0x20, 0x3c, 0x3e,
	0x0a, 0x3c, 0x3e, 0x3c, 0x3e, 0x3c, 0x3e, 0x20,
	0x26, 0x3c, 0x61, 0x3e, 0x20, 0x26, 0x3c, 0x2f,
	0x61, 0x3e, 0x20, 0x3c, 0x3e, 0x0a, 0x3c, 0x3e,
	0x3c, 0x3e, 0x3c, 0x3e, 0x20, 0x26, 0x61, 0x6d,
	0x70, 0x3b, 0x20, 0x3c, 0x3e, 0x0a, 0x3c, 0x3e,
	0x3c, 0x3e, 0x3c, 0x3e, 0x20, 0x26, 0x61, 0x61,
	0x61, 0x20, 0x3c, 0x3e, 0x0a, 0x3c, 0x3e, 0x3c,
	0x3e, 0x26, 0x71, 0x75, 0x6f, 0x74, 0x3b, 0x20,
	0x3c, 0x3e, 0x3c, 0x3e, 0x0a, 0x3c, 0x3e, 0x3c,
	0x3e, 0x3c, 0x3e, 0x20, 0x26, 0x6c, 0x74, 0x3b,
	0x20, 0x3c, 0x3e, 0x0a, 0x3c, 0x3e, 0x3c, 0x3e,
	0x3c, 0x3e, 0x26, 0x3c, 0x3e, 0x0a, 0x3c, 0x3e,
	0x3c, 0x3e, 0x3c, 0x3e, 0x3c, 0x3e, 0x0a, 0x3c,
	0x3e, 0x3c, 0x3e, 0x3c, 0x3e, 0x3b, 0x3c, 0x3e,
	0x0a, 0x00
};

LOCAL UNITTEST_RESULT test_parser_2()
{
	LINK test_lnk;
	W fd, err, num;
	VID vid;
	datcache_t *cache;
	datparser_t *parser;
	datparser_res_t *res = NULL;
	UNITTEST_RESULT result = UNITTEST_RESULT_PASS;

	fd = test_parser_util_gen_file(&test_lnk, &vid);
	if (fd < 0) {
		return UNITTEST_RESULT_FAIL;
	}
	cls_fil(fd);

	cache = datcache_new(vid);
	datcache_appenddata(cache, test_parser_testdata_02, strlen(test_parser_testdata_02));

	parser = datparser_new(cache);

	num = 0;
	for (;;) {
		err = datparser_getnextres(parser, &res);
		if (err != 1) {
			break;
		}
		if (res != NULL) {
			num++;
			datparser_res_delete(res);
		} else {
			break;
		}
	}

	if (num != 14) {
		printf("res total number is fail\n");
		result = UNITTEST_RESULT_FAIL;
	}

	datparser_delete(parser);

	datcache_delete(cache);

	err = odel_vob(vid, 0);
	if (err < 0) {
		printf("error odel_vob:%d\n", err >> 16);
		result = UNITTEST_RESULT_FAIL;
	}
	err = del_fil(NULL, &test_lnk, 0);
	if (err < 0) {
		printf("error del_fil:%d\n", err >> 16);
		result = UNITTEST_RESULT_FAIL;
	}

	return result;
}

EXPORT VOID test_parser_main(unittest_driver_t *driver)
{
	UNITTEST_DRIVER_REGIST(driver, test_parser_1);
	UNITTEST_DRIVER_REGIST(driver, test_parser_2);
}
